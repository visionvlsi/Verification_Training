LEVEL-2:

 Design and implement JK-FlipFlop, D-FlipFlop and T-FlipFlop.
 Design and implement a system which takes 4-bit data and shifts left, right, reverses, passes the data depending upon a control signal(Don’t use any registers).
 Design and implement a 4-bit Counter
 Design and implement a system which takes 8-bit data and stores in memory and based on request it should send data ROM/ RAM.

______________
1. Design and implement JK-FlipFlop, D-FlipFlop and T-FlipFlop.

// JK - Flipflop

module jkff(j,k,clk,rst,q,qbar);
input j,k;
input clk,rst;
output reg q,qbar;
always@(posedge clk)
begin
if(rst)
begin
q<=0;
qbar<=1;
end
else
case({j,k})
2'b00: begin q<=q; qbar<=qbar; end
2'b01: begin q<=0; qbar<=1; end
2'b10: begin q<=1; qbar<=0; end
2'b11: begin q<=~q; qbar<=~qbar; end
endcase
end
endmodule

// testbench
`timescale 1ns/1ps
module tb;
 reg j,k;
 reg clk,rst;
 wire q,qbar;
 jkff ins1(j,k,clk,rst,q,qbar);
 
  
  initial begin 
    $monitor($time, " clk=%b,rst=%b,j=%b,k=%b,q=%b,qbar=%b",clk,rst,j,k,q,qbar);
       clk=0;
       rst=0;
       forever
         #5 clk=~clk;
  end
  initial
    begin
     @(posedge clk);
    @(negedge clk) rst=1;
    @(posedge clk);
    @(negedge clk) rst=0; j=0; k=0;
     @(posedge clk);
    @(negedge clk)  j=0; k=1;
     @(posedge clk);
    @(negedge clk) j=1; k=0;
     @(posedge clk);
    @(negedge clk)  j=1; k=1;
     @(posedge clk);
    #10;
    $finish;
  end
endmodule

// https://www.edaplayground.com/x/qTdy

// DFF

module dff(clk,rst,d,q,qbar);
input clk,rst;
input d;
output reg q, qbar;
always@(posedge clk)
begin
if(rst)
begin 
q<=0;
qbar<=1;
end
else
case(d)
0: begin q<=0; qbar<=1; end
1: begin q<=1; qbar<=0; end
endcase
end
endmodule

// testbench
`timescale 1ns/1ps
module tb;
 reg j,k;
 reg clk,rst;
 wire q,qbar;
 dff ins1(clk,rst,d,q,qbar);
 
  
  initial begin 
    $monitor($time, " clk=%b,rst=%b,d=%b,q=%b,qbar=%b",clk,rst,d,q,qbar);
       clk=0;
       rst=0;
       forever
         #5 clk=~clk;
  end
  initial
    begin
     @(posedge clk);
     @(negedge clk) rst=1;
     @(posedge clk);
     @(negedge clk) rst=0; d=0;
     @(posedge clk);
     @(negedge clk)  d=1;
     @(posedge clk);
     @(posedge clk);
    #10;
    $finish;
  end
endmodule

//https://www.edaplayground.com/x/eCrd

// T FF

module dff(clk,rst,t,q,qbar);
input clk,rst;
input t;
output reg q, qbar;
always@(posedge clk)
begin
if(rst)
begin 
q<=0;
qbar<=1;
end
else
case(t)
0: begin q<=q; qbar<=qbar; end
1: begin q<=~q; qbar<=~qbar; end
endcase
end
endmodule

// testbench
`timescale 1ns/1ps
module tb;
 reg t;
 reg clk,rst;
 wire q,qbar;
 dff ins1(clk,rst,t,q,qbar);
 
  
  initial begin 
    $monitor($time, " clk=%b,rst=%b,t=%b,q=%b,qbar=%b",clk,rst,t,q,qbar);
       clk=0;
       rst=0;
       forever
         #5 clk=~clk;
  end
  initial
    begin
     @(posedge clk);
     @(negedge clk) rst=1;
     @(posedge clk);
     @(negedge clk) rst=0; t=0;
     @(posedge clk);
     @(negedge clk)  t=1;
     @(posedge clk);
     @(posedge clk);
    #10;
    $finish;
  end
endmodule

//https://www.edaplayground.com/x/r_RM
